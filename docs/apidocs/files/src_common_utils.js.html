<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src&#x2F;common&#x2F;utils.js - jStorage</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="jStorage"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Driver.html">Driver</a></li>
            
                <li><a href="..&#x2F;classes/DriverStub.html">DriverStub</a></li>
            
                <li><a href="..&#x2F;classes/Events.html">Events</a></li>
            
                <li><a href="..&#x2F;classes/Helper.html">Helper</a></li>
            
                <li><a href="..&#x2F;classes/Memory.html">Memory</a></li>
            
                <li><a href="..&#x2F;classes/utils.Bind.html">utils.Bind</a></li>
            
                <li><a href="..&#x2F;classes/utils.CallbackGroup.html">utils.CallbackGroup</a></li>
            
                <li><a href="..&#x2F;classes/utils.Delegate.html">utils.Delegate</a></li>
            
                <li><a href="..&#x2F;classes/utils.Events.html">utils.Events</a></li>
            
                <li><a href="..&#x2F;classes/utils.KeyNav.html">utils.KeyNav</a></li>
            
                <li><a href="..&#x2F;classes/utils.Options.html">utils.Options</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Driver.html">Driver</a></li>
            
                <li><a href="..&#x2F;modules/Events.html">Events</a></li>
            
                <li><a href="..&#x2F;modules/utils.Mixins.html">utils.Mixins</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src&#x2F;common&#x2F;utils.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var jStore = jStore || {};

jStore.utils = {};
&#x2F;&#x2F;various utility methods, mixins and Objects
!function(ns, utils){

    &#x2F;&#x2F;shorthand for object.hasOwnProperty
    function has(obj, item){
        return Object.prototype.hasOwnProperty.call(obj,item);    
    } 

    &#x2F;*
     * returns the value of a chain of variables if exists
     * 
     * instead of doing
     * loaded = (book &amp;&amp; book.current_page &amp;&amp; book.current_page.loaded)
     * 
     * you can do
     *
     * loaded = find(book,&#x27;current_page&#x27;,&#x27;loaded&#x27;);
     * 
     * or
     * 
     * loaded = find(book,&#x27;current_page.loaded&#x27;);
     *
     *&#x2F;
    function find(obj &#x2F;*[,item [,item ...]]*&#x2F;){
        var list = Array.prototype.splice.call(arguments,1),
            name;
      
    
        if (!obj) return false;

        if (list.length == 1 &amp;&amp; list[0].indexOf(&#x27;.&#x27;)&gt;-1){
            list = list[0].split(&#x27;.&#x27;);   
        }

        while (name = list.shift()){
            if (obj == null) return null;
            obj = obj[name];
        }

        return obj;    
    }

    &#x2F;*
     * checks for long chains of existance
     * 
     * instead of doing if (book &amp;&amp; book.current_page &amp;&amp; book.current_page.loaded)
     * 
     * if (exists(book,&#x27;current_page&#x27;,&#x27;loaded&#x27;)) ...
     * 
     * or
     * 
     * if (exists(book,&#x27;current_page.loaded&#x27;)) ....
     *
     *&#x2F;
    function exists(obj &#x2F;*[,item [,item ...]]*&#x2F;){
        return find.apply(null, arguments) != null;
    }
    
    &#x2F;&#x2F;Taken from Mootools
    function bind(that){
        var self = this,
            args = arguments.length &gt; 1 ? Array.prototype.slice.call(arguments, 1) : null,
            F = function(){};

        var bound = function(){
            var context = that, length = arguments.length;
            if (this instanceof bound){
                F.prototype = self.prototype;
                context = new F;
            }

            var result = (!args &amp;&amp; !length)
                ? self.call(context)
                : self.apply(context, args &amp;&amp; length ? args.concat(Array.prototype.slice.call(arguments, 0)) : args || arguments);
            
            return context == that ? result : context;
        };

        return bound;
    }

    if (false === (&#x27;bind&#x27; in Function.prototype)){
        Function.prototype.bind = bind;    
    }

    this.bind = function(fn,scope){
        return fn.bind(scope);    
    };

    this.has = has;
    this.exists = exists;
    this.find = find;

    this.toArray = function(item){
        return (item instanceof Array ? item : [item]);    
    };

    &#x2F;&#x2F;removes an item from an array based on it&#x27;s index
    this.arrRemove = function arrRemove(arr,index){
        return arr.splice(index,1);
    };

    this.removeItem  = function(arr,item){
        var index = arr.indexOf(item);
        if (index &lt; 0 ) return;

        return arr.splice(index,1);
    };

    this.indexOf = function(arr,item){
        return arr.indexOf(item);    
    };                          

    this.keys = Object.keys || function(obj){
        var arr = [],key;
        for (key in obj) if (has(obj,key)) arr.push(key);
        return arr;
    };

    this.merge = Object.merge || function(target, params){
        var key, i, obj;

        for (i = 1; obj = arguments[i]; i++){
            for (key in obj) if (has(obj,key)){
                target[key] = obj[key];
            }   
        }

        return target;
    };

    this.prefetch = function(){
        var i, src, img;

        for (i=0; src = arguments[i]; i++){
            img = new Image();
            img.src = src;
        }
    };

    &#x2F;**
     * This function waits until all specified font-families loaded and then executes a callback function.
     * Supplied font-families should be already defined in the document, by URL or base64.
     * If after specific threshold time fonts still not loaded, callback will be invoked.
     * @method onFontsLoad
     * 
     * @param {Array} fontFamiliesArray Array of font-families to test
     * @param {Function} fontsLoadedCallback Callback function to call after all font-families loaded
     *&#x2F;
    this.onFontsLoad = function onFontsLoad(fontFamiliesArray, fontsLoadedCallback) {
        var testContainer,
            testDiv,
            origHeight,
            origWidth,
            i,
            clonedDiv,
            interval,
            tryCount = 0,
            maxNumOfTries = 5,
            tryIntervalMs = 500;
        
        function testDivDimensions() {
            var i, testDiv;
            for (i = testContainer.childNodes.length - 1; i &gt;= 0; i--) {
                testDiv = testContainer.childNodes[i];
                if (testDiv.offsetWidth !== origWidth || testDiv.offsetHeight !== origHeight) {
                    &#x2F;&#x2F; Div&#x27;s dimensions changed, this means its font loaded, remove it from testContainer div
                    testDiv.parentNode.removeChild(testDiv);
                }
            }
        }
        
        &#x2F;&#x2F; Use pretty big fonts &quot;40px&quot; so smallest difference between standard
        &#x2F;&#x2F; &quot;serif&quot; fonts and tested font-family will be noticable.
        testContainer = document.createElement(&quot;div&quot;);
        testContainer.style.cssText = &quot;position:absolute; left:-1000px; top:-1000px; font-family:serif; font-size:40px;&quot;; 
        document.body.appendChild(testContainer);
        
        testDiv = document.createElement(&quot;div&quot;);
        testDiv.appendChild(document.createTextNode(&quot;The quick brown fox jumps over the lazy dog&quot;));
        
        &#x2F;&#x2F; Add div for each font-family
        for (i = 0; i &lt; fontFamiliesArray.length; i++) {
            clonedDiv = testDiv.cloneNode(true);
            testContainer.appendChild(clonedDiv);
            &#x2F;&#x2F; Get dimensions of div before applying font-family,
            &#x2F;&#x2F; do it once because initially all divs will have same dimensions.
            if (i === 0) {
                origHeight = clonedDiv.offsetHeight;
                origWidth = clonedDiv.offsetWidth;
            }
            &#x2F;&#x2F; Apply tested font-family
            clonedDiv.style.fontFamily = fontFamiliesArray[i];
        }
        
        &#x2F;&#x2F; Check if dimension of all divs changed immediately after applying font-family
        &#x2F;&#x2F; maybe all fonts were already loaded so we don&#x27;t need to poll and wait.
        testDivDimensions();
        
        &#x2F;&#x2F; Check that there is at least one div, means at least one not loaded font.
        if (testContainer.childNodes.length) {
            &#x2F;&#x2F; Poll div for their dimensions every tryIntervalMs.
            interval = window.setInterval(function() {
                &#x2F;&#x2F; Loop through all divs and check if their dimensions changed.
                testDivDimensions();
                &#x2F;&#x2F; If no divs remained, then all fonts loaded.
                &#x2F;&#x2F; We also won&#x27;t wait too much time, maybe some fonts are broken.
                if (testContainer.childNodes.length === 0 || tryCount === maxNumOfTries) {
                    &#x2F;&#x2F; All fonts are loaded OR (maxNumOfTries * tryIntervalMs) ms passed.
                    window.clearInterval(interval);
                    testContainer.parentNode.removeChild(testContainer);
                    fontsLoadedCallback();
                } else {
                    tryCount++;
                }
            }, tryIntervalMs);
        } else {
            &#x2F;&#x2F; All fonts are loaded
            testContainer.parentNode.removeChild(testContainer);
            fontsLoadedCallback();
        }
    };
    
    this.createIScroll = function(el,obj,opts){
        var iscroll = new iScroll(el,opts);

        if (obj) obj.iscroll = iscroll;

        if (exists(obj,&#x27;addEvent&#x27;)) obj.addEvent(&#x27;destroy&#x27;,function(){
            delete obj[&#x27;iscroll&#x27;];

            iscroll.destroy();
        });
    };

    &#x2F;&#x2F;mimickin corc&#x27;s Object.create
    this.inherit = function(obj, parent, props){
        var key;
        function F(){}

        F.prototype = parent.prototype;
        obj.prototype = new F();
        obj.prototype.constructor = obj;

        for (key in props) if (has(props, key)){
            obj.prototype[key] = props[key];
        }

        obj.prototype.$parent = function(name,args){
            return parent.prototype[name].apply(this,args || []);
        };

        obj.prototype.$construct = function(args){
            parent.apply(this, args || []);
        };

        return obj;
    };

    this.log = function(arg1,arg2){
        if (jStore.prod) return;

        if (exists(window,&#x27;console.log&#x27;)){
            console.log.apply ? console.log.apply(console,arguments) : console.log(arg1,arg2);
        }
    }; 

    this.warn = function(arg1,arg2){
        if (jStore.prod) return;

        var fn_name = exists(window,&#x27;console.warn&#x27;) ? &#x27;warn&#x27; : exists(window,&#x27;console.log&#x27;) ? &#x27;log&#x27; : null;

        if (!fn_name) return;

        console[fn_name].apply ? console[fn_name].apply(console,arguments) : console[fn_name](arg1,arg2);
    };

    &#x2F;**
     * sendSelectedText used by logItem.prepare method to parse MenuSelection context.selectedText and highlight type
     * @param e : LogItem object
     *&#x2F;
    this.sendSelectedText = function (e) {
        var args = e.args,
            selectedText = ns.utils.find(args, &#x27;context.selectedText&#x27;);

        if (!selectedText) {
            selectedText = ns.utils.find(args, &#x27;selectedText&#x27;);
        }
        
        if(!selectedText){
            return false;
        }

        this.moreData = {
            &#x27;selectedText&#x27;:encodeURIComponent(selectedText),
            &#x27;length&#x27;:selectedText.length
        };

        if (args.type) {
            this.moreData.highlightStyle = args.type;
        }
    }; 

    &#x2F;**
     * a syntax sugar for calling other object&#x27;s methods on an object
     * 
     * Returned function will function just like inherit&#x27;s $parent, only that if you only pass it arguments it will call the constructor (like inherit#$construct)
     *
     * @method bindParent
     * @static
     *
     * @param {Object} target object
     * @param {Object} parent object
     * @param {bool}   [use_directly] if set to true, will use parent directly, rather than use it&#x27;s prototype
     *
     * @example
     *
     *    this.parent = utils.bindParent(this, Foo);
     *
     *    this.parent([some_arg]); &#x2F;&#x2F;will call Foo - bound to obj
     *    this.parent(&#x27;bar&#x27;,[some_arg]); &#x2F;&#x2F;will call Foo.prototype.bar - bound to obj
     *
     * @return {Function}
     *&#x2F;
    this.bindParent = function(obj, parent, use_directly){
        var construct = parent;

        if (!use_directly){
            parent = parent.prototype;    
        }    

        return function(method, args){
            if (!args &amp;&amp; typeof method != &#x27;string&#x27;){
                args = method;
                method = construct;    
            }else{
                method = parent[method];    
            }

            return method.apply(obj, args || []);
        };
    };  

    &#x2F;*
     * provide a way to open link in new Safari mobile window while the application is in home screen mode (running as standalone web app)
     * @param url {String} target url
     *&#x2F;
    this.openLinkInNewWindow = function(url){
        var link = document.createElement(&#x27;a&#x27;),
            clickevent = document.createEvent(&#x27;Event&#x27;);

        link.target = &#x27;_blank&#x27;;
        link.href = url;

        clickevent.initEvent(&#x27;click&#x27;, true, false);
        link.dispatchEvent(clickevent);
    };

    &#x2F;**
     * This object allows you to pass a list of events to listen to. Once all of them are done, it will fire a callback
     * @class utils.CallbackGroup
     * @constructor
     *
     * @param {object} params
     *  @param {object} params.events a map of event-name =&gt; event target
     *  @param {function} callback    a function to run once events are done
     *
     *  @example
     *      var group = new utils.CallbackGroup({
     *          callback : function(){console.log(&#x27;foo&#x27;);},
     *          events :{
     *              &#x27;load&#x27; : this.bridge,
     *              &#x27;iclick&#x27; : this.element
     *          }
     *      });
     *&#x2F;
    this.CallbackGroup = function CallbackGroup(params){
        var ev, counter = 0, max = 0,
            stopped,
            _params = params;

        function attach(target, type){
            if (target.addEventOnce){
                target.addEventOnce(type,fire);    
            }else{
                target.addEventListener(type, function once(){
                    fire();    
                    target.removeEventListener(type,once,false);
                }, false);    
            }
        }

        &#x2F;**
         * cancels the stack
         * @method stop
         * @param {boolean} [run] if set to true will run the callback
         *&#x2F;
        function stop(run){ 
            var ev;

            if (run){
                _params.callback();
            }

            stopped = true;

            _params = null;
        } 

        function fire(){
            counter++;
            if (counter==max &amp;&amp; !stopped){
                stop(true);    
            }
        }

        for (ev in _params.events){
            attach(_params.events[ev], ev);
            max++;
        }

        return {
            constructor : CallbackGroup,
            stop : stop
        };
    };
    

    this.logStorage = function logStorage(){
        var arr = [];
        for (var name in localStorage) arr.push({name : name, l : localStorage[name].length});

        arr.sort(function(a,b){return +a.l &gt; +b.l});

        arr.forEach(function(p){
            console.log(p.l + &#x27;:&#x27; + p.name);    
        });
    };     

}.apply(jStore.utils, [jStore, jStore.utils]);

(function(ns){
    
    var logMethods = [&quot;error&quot;, &quot;warn&quot;, &quot;info&quot;, &quot;log&quot;],
        loggers = {},
        referenceFunction = null;
    
    function empty() {}
    
    function bind(method, args) {
        var i, argStr = &quot;&quot;, func;
        if (args &amp;&amp; args.length) {
            for (i = 0; i &lt; args.length; i++) {
                argStr += &quot;, arguments[ &quot; + (i + 1) + &quot;]&quot;; 
            }
            func = new Function(&quot;method&quot;, &quot;return window.console[method].bind(window.console&quot; + argStr + &quot;);&quot;);
            return func.apply(this, [method].concat(args));
        } else {
            return window.console[method].bind(window.console);
        }
    }
    
    function direct(method, args) {
        &#x2F;&#x2F; Can&#x27;t do much with args using this method :(
        return window.console[method];
    }
    
    function apply(method, args) {
        return function() {
            window.console[method].apply(window.console, args.concat(Array.prototype.slice.call(arguments)));
        };
    }
    
    function setReferenceFunction() {
        var testRef;
        try {
            testRef = window.console.log.bind(window.console);
            testRef(&quot;Test binding console methods&quot;);
            referenceFunction = bind;
        } catch(e) {
            window.console.info(&quot;Can&#x27;t bind console methods&quot;);
            try {
                testRef = window.console.log;
                testRef(&quot;Test direct reference to console methods&quot;);
                referenceFunction = direct;
            } catch(er) {
                window.console.info(&quot;Can&#x27;t set direct reference to console methods&quot;);
                referenceFunction = apply;
            }
        }
    }
    
    &#x2F;**
     * Logger Class.
     * Creates a logger.
     * 
     * @param {String} loggerName Name of the logger. If a logger with supplied name
     * already exists, that logger instance is returned and its level will be updated
     * to a passed level or will stay with old level if level parameter wasn&#x27;t passed.
     * @param {Logger.logLevels ENUM} level Debug level of the logger.
     *&#x2F;
    function Logger(loggerName, level) {
        
        if (typeof loggerName !== &quot;string&quot;) {
            if (window.console) {
                window.console.warn(&quot;Attempt to instantiate Logger with illegal loggerName, using Root logger&quot;);
            }
            loggerName = &quot;Root&quot;;
        }
        
        if (loggers[loggerName]) {
            if (level !== undefined) {
                loggers[loggerName].setLevel(level);
            }
            return loggers[loggerName];
        }
        
        this.name = loggerName;
        this.setLevel(level);
        
        loggers[this.name] = this;
    }

    Logger.getLogger = function(loggerName, level) {
        if (loggers[loggerName]) {
            if (level !== undefined) {
                loggers[loggerName].setLevel(level);
            }
            return loggers[loggerName];
        } else {
            return new Logger(loggerName, level);
        }
    };
    Logger.logLevels = {
        ERROR: 0,
        WARN: 1,
        INFO: 2,
        DEBUG: 3
    };
    Logger.prototype.setLevel = function(level) {
        var i = 0;
        
        if (level === undefined) {
            level = 0;
        }
        
        if (typeof level !== &quot;number&quot; || level &lt; 0 || level &gt; 3) {
            if (window.console) {
                window.console.warn(&quot;Attempt to set illegal log level: &#x27;&quot; + level + &quot;&#x27;, log level is set to 0.&quot;);
            }
            level = 0;
        }
        
        this.level = level;
        
        if (window.console) {
            if (referenceFunction === null) {
                setReferenceFunction();
            }
            
            for (i; i &lt;= level; i++) {
                if (window.console[logMethods[i]]) {
                    this[logMethods[i]] = referenceFunction(logMethods[i], [this.name + &quot;:&quot;]);
                    if (logMethods[i] === &quot;log&quot;) {
                        this.debug = this[logMethods[i]];
                    }
                } else {
                    this[logMethods[i]] = empty;
                }
            }
        }
        
        for (i; i &lt; logMethods.length; i++) {
            this[logMethods[i]] = empty;
            if (logMethods[i] === &quot;log&quot;) {
                this.debug = this[logMethods[i]];
            }
        }
    };
    
    ns.Logger = Logger;
    
}.apply(jStore.utils, [jStore.utils]));



    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
